ActionData.cpp """
#include "ActionData.h"
#include <iostream>


ActionData::ActionData(std::istream& is, std::ostream& os):
    mIs(is), mOs(os), mHasQuit(false), mNumberGrid(0) {
}
ActionData::~ActionData() {
    if (mNumberGrid != 0) {
        delete mNumberGrid;
        mNumberGrid = 0;
    }
}
std::istream& ActionData::getIS() {
    return mIs;
}
std::ostream& ActionData::getOS() {
    return mOs;
}
PPM& ActionData::getInputImage1() {
    return mInputImageOne;
}
PPM& ActionData::getInputImage2() {
    return mInputImageTwo;
}
PPM& ActionData::getOutputImage() {
    return mOutputImage;
}
bool ActionData::getDone() const {
    return mHasQuit;
}
void ActionData::setDone() {
    mHasQuit = true;
}
NumberGrid& ActionData::getGrid() {
    return *mNumberGrid;
}
void ActionData::setGrid(NumberGrid *grid) {
    if (mNumberGrid != 0) {
        delete mNumberGrid;
    }
    mNumberGrid = grid;
}
"""

ActionData.h """
#ifndef _ACTIONDATA_H_
#define _ACTIONDATA_H_
#include <iostream>
#include "PPM.h"

class ActionData {
public:
    ActionData( std::istream& is, std::ostream& os );
    ~ActionData();
    std::istream& getIS();
    std::ostream& getOS();
    PPM& getInputImage1();
    PPM& getInputImage2();
    PPM& getOutputImage();
    bool getDone() const;
    void setDone();
    NumberGrid& getGrid();
    void setGrid(NumberGrid *grid);
protected:
    std::istream& mIs;
    std::ostream& mOs;
    PPM mInputImageOne;
    PPM mInputImageTwo;
    PPM mOutputImage;
    bool mHasQuit;
    NumberGrid *mNumberGrid;
private:
};



#endif
"""

image_menu.h """

#ifndef _IMAGE_MENU_H_
#define _IMAGE_MENU_H_
#include <iostream>
#include <string>
#include "MenuData.h"
#include "NumberGrid.h"


//user_io.cpp
std::string getString( ActionData& action_data, const std::string& prompt );
int getInteger( ActionData& action_data, const std::string& prompt );
double getDouble( ActionData& action_data, const std::string& prompt );
int askQuestions3( ActionData& action_data );
//exam 1
int askHeroQuestions( ActionData& action_data );
//assignment 5 user_io functions
std::string getChoice( ActionData& action_data );
void commentLine( ActionData& action_data );
void quit(ActionData& action_data);

//image_drawing.cpp
void diagonalQuadPattern( ActionData& action_data );
void stripedDiagonalPattern( ActionData& action_data );
//exam 1
void simpleSquaresPattern( ActionData& action_data );
//assignment 5 image_drawing functions
void setSize( ActionData& action_data );
void setMaxColorValue( ActionData& action_data );
void setChannel( ActionData& action_data );
void setPixel( ActionData& action_data );
void clearAll( ActionData& action_data );
//assignment7
void drawCircle(ActionData& action_data);
void drawBox(ActionData& action_data);
//exam 2
void drawSquare(ActionData& action_data);
//assignment 8
void configureGrid(ActionData& action_data);
void setGrid(ActionData& action_data);
void applyGrid(ActionData& action_data);

// image_output.cpp
void drawAsciiImage( ActionData& action_data );
void writeUserImage( ActionData& action_data );
// assignment 5
void copyImage( ActionData& action_data );
void readUserImage1( ActionData& action_data );
void readUserImage2( ActionData& ation_data );

// controllers.cpp
int assignment1( std::istream& is, std::ostream& os );
int assignment2( std::istream& is, std::ostream& os );
int assignment3( std::istream& is, std::ostream& os );
//exam 1 controllers
int hero( std::istream& is, std::ostream& os );
int simple_squares_ascii( std::istream& is, std::ostream& os );
//assignment 5
void showMenu( MenuData& menu_data, ActionData& action_data );
void takeAction(const std::string& choice, MenuData& menu_data, ActionData& action_data);
void configureMenu( MenuData& menu_data );
int imageMenu(std::istream& is, std::ostream& os);

//image_filters.cpp
void plusEquals( ActionData& action_data );
void minusEquals( ActionData& action_data );
void timesEquals( ActionData& action_data );
void divideEquals( ActionData& action_data );
void plus( ActionData& action_data );
void minus( ActionData& action_data );
void times( ActionData& action_data );
void divide( ActionData& action_data );
//assignemnt7
void grayFromRed(ActionData& action_data);
void grayFromGreen(ActionData& action_data);
void grayFromBlue(ActionData& action_data);
void grayFromLinearColorimetric(ActionData& action_data);
//exam2
void orangeFilter(ActionData& action_data);
void timesEqualsPPM(ActionData& action_data);



#endif /*_IMAGE_MENU_H_*/
"""

image_drawing.cpp """
#include <iostream>
#include "image_menu.h"
#include <string>
#include <cmath>


void diagonalQuadPattern( ActionData& action_data ) {
    action_data.getInputImage1().setMaxColorValue(255);
	int height;
	int width;
	int tophalf;
	
	int row;
	int col;
	
	height = getInteger( action_data, "Image height? ");
	width = getInteger( action_data, "Image width? ");
	action_data.getInputImage1().setHeight(height);
	action_data.getInputImage1().setWidth(width);
	
	tophalf = (action_data.getInputImage1().getHeight() / 2) ;
	
	// top half for red, bottom half for red
	for(row = 0; row < tophalf; row++){
		for(col = 0; col <= action_data.getInputImage1().getWidth(); col++){
			action_data.getInputImage1().setChannel(row, col, 0, 0);
		}};
	for(row = tophalf; row <= action_data.getInputImage1().getHeight(); row++) {
		for(col = 0; col < action_data.getInputImage1().getWidth(); col++) {
			action_data.getInputImage1().setChannel(row, col, 0, 255);
		}};
	
	// left half for blue, right half for blue
	for(row = 0; row <= action_data.getInputImage1().getHeight(); row++){
		for(col = 0; col < action_data.getInputImage1().getWidth() / 2; col++){
			action_data.getInputImage1().setChannel(row, col, 2, 0);
		}};

	for(row = 0; row <= action_data.getInputImage1().getHeight(); row++) {
		for(col = action_data.getInputImage1().getWidth() / 2; col <= action_data.getInputImage1().getWidth(); col++) {
			action_data.getInputImage1().setChannel(row, col, 2, 255);
		}};
	
	// function for designating green based off position
	for(row = 0; row <= action_data.getInputImage1().getHeight(); row++){
		for(col = 0; col <= action_data.getInputImage1().getWidth(); col++){
			action_data.getInputImage1().setChannel(row, col, 1, ((2*row) + (2*col)) % 256);
		}};
	return;
}

void stripedDiagonalPattern( ActionData& action_data ) {
    /*(void) action_data.getIS();
    (void) action_data.getOS();
    (void) action_data.getInputImage1();*/
    int height = 0, width = 0;
    height = getInteger( action_data, "Image height? ");
    width = getInteger( action_data, "Image width? ");
    
    
    action_data.getInputImage1().setHeight(height);
    action_data.getInputImage1().setWidth(width);
    
    int mcv = (height + width) / 3;
    if (mcv > 255) {
        mcv = 255;
    }
    
    action_data.getInputImage1().setMaxColorValue(mcv);
    
    int row, col;
    //define red channel values
    
    for ( row = 0; row < height / 2; row++) {
        for( col = 0; col < width; col++) {
            action_data.getInputImage1().setPixel(row, col, 0, -1, -1);
        }
    } 
    for( row = height / 2; row < height; row++) {
        for( col = 0; col < width; col++ ) {
            if( (row % 3) == 0 ) {
                action_data.getInputImage1().setPixel(row, col, 0, -1, -1);
            } else {
                action_data.getInputImage1().setPixel(row, col, mcv, -1, -1);
            }
        }
    }
    //define green channel values
    
    for( row = 0; row < height; row++) {
        for( col = 0; col < width; col++) {
            action_data.getInputImage1().setPixel(row, col, -1, (row + width - col - 1) % (mcv + 1), -1);
        }
    }
    // define blue channel values
    for( row = 0; row < height; row++) {
        for( col = 0; col < width; col++) {
            if(col < row) {
                action_data.getInputImage1().setPixel(row, col, -1, -1, 0);
            } else {
                action_data.getInputImage1().setPixel(row, col, -1, -1, mcv);
            }
        }
    }/*
    for( row = 0; row < height; row++) {
        for( col = 0; col < width; col++) {
            action_data.getInputImage1().setPixel(row, col, 255, 255, 255);
        }
    }*/

}

void setSize( ActionData& action_data ) {
    int h, w;
    h = getInteger( action_data, "Height? ");
    w = getInteger( action_data, "Width? ");
    action_data.getInputImage1().setHeight(h);
    action_data.getInputImage1().setWidth(w);
}

void setMaxColorValue( ActionData& action_data ) {
    int mcv = getInteger( action_data, "Max color value? ");
    action_data.getInputImage1().setMaxColorValue(mcv);
}

void setChannel( ActionData& action_data ) {
    int row, col, chan, val;
    row = getInteger( action_data, "Row? ");
    col = getInteger( action_data, "Column? ");
    chan = getInteger( action_data, "Channel? ");
    val = getInteger( action_data, "Value? ");
    action_data.getInputImage1().setChannel(row, col, chan, val);
}

void setPixel( ActionData& action_data ) {
    int row, col, red, green, blue;
    row = getInteger( action_data, "Row? ");
    col = getInteger( action_data, "Column? ");
    red = getInteger( action_data, "Red? ");
    green = getInteger( action_data, "Green? ");
    blue = getInteger( action_data, "Blue? ");
    action_data.getInputImage1().setPixel(row, col, red, green, blue);
}

void clearAll( ActionData& action_data ) {
    int width = action_data.getInputImage1().getWidth();
    int height = action_data.getInputImage1().getHeight();
    for( int i=0; i < height; i++ ) {
        for( int j=0; j < width; j++ ) {
            for( int c=0; c<=2; c++ ) {
                action_data.getInputImage1().setChannel(i,j,c,0);
            }
        }
    }
}

void simpleSquaresPattern( ActionData& action_data ) {
    int size, row, col;
    size = getInteger( action_data, "Image size? ");
    action_data.getInputImage1().setHeight(size);
    action_data.getInputImage1().setWidth(size);

    //red
    for(row = 0; row < size / 2; row++) {
        for( col = 0; col < size; col++) {
            action_data.getInputImage1().setChannel(row, col, 0, 127);
        }
    }
    for(row = size / 2; row < size; row++) {
        for( col = 0; col < size; col++) {
            action_data.getInputImage1().setChannel(row, col, 0, 255);
        }
    }
    //blue
    for(row = 0; row < size; row++) {
        for( col = 0; col < size / 2; col++) {
            action_data.getInputImage1().setChannel(row, col, 1, 0);
        }
    }
    for(row = 0; row < size; row++) {
        for( col = size / 2; col < size; col++) {
            action_data.getInputImage1().setChannel(row, col, 1, 255);
        }
    }
    //green
    for(row = size; row < size; row++) {
        for( col = 0; col < size; col++) {
            action_data.getInputImage1().setChannel(row, col, 2, 255);
        }
    }
}


void drawCircle(ActionData& action_data) {
    int cenRow, cenCol, r, g, b, delRow, delCol;
    double distance, rad;

    cenRow = getInteger(action_data, "Center Row? ");
    cenCol = getDouble(action_data, "Center Column? ");
    rad = getInteger(action_data, "Radius? ");
    r = getInteger(action_data, "Red? ");
    g = getInteger(action_data, "Green? ");
    b = getInteger(action_data, "Blue? ");

    int width = action_data.getInputImage1().getWidth();
    int height = action_data.getInputImage1().getHeight();

    for( int i=0; i < height; i++ ) {
        for( int j=0; j < width; j++ ) {
            delRow = i - cenRow;
            delCol = j - cenCol;
            distance = std::sqrt((delRow * delRow) + (delCol * delCol));
            if(distance <= rad) {
                action_data.getInputImage1().setPixel(i, j, r,g,b);
            }
        }
    }
}
void drawBox(ActionData& action_data) {
    int tRow, bRow, lCol, rCol, r, g, b;
    int width = action_data.getInputImage1().getWidth();
    int height = action_data.getInputImage1().getHeight();

    tRow = getInteger(action_data, "Top Row? ");
    lCol = getInteger(action_data, "Left Column? ");
    bRow = getInteger(action_data, "Bottom Row? ");
    rCol = getInteger(action_data, "Right Column? ");

    r = getInteger(action_data, "Red? ");
    g = getInteger(action_data, "Green? ");
    b = getInteger(action_data, "Blue? ");


    for( int row=0; row < height; row++ ) {
        for( int col=0; col < width; col++ ) {
            if((row >= tRow) && (row <= bRow) && (col <= rCol) && (col >= lCol)) {
                action_data.getInputImage1().setPixel(row, col, r,g,b);
            }
        }
    }
}

void drawSquare(ActionData& action_data) {
    int mrow, mcol, r,g,b, height, width;
    double size, hsize;
    mrow = getInteger(action_data, "Row? ");
    mcol = getInteger(action_data, "Column? ");
    size = getDouble(action_data, "Size? ");
    r = getInteger(action_data, "Red? ");
    g = getInteger(action_data, "Green? ");
    b = getInteger(action_data, "Blue? ");
    height = action_data.getInputImage1().getHeight();
    width = action_data.getInputImage1().getWidth();
    hsize = size / 2;

    for( int row=0; row < height; row++ ) {
        for( int col=0; col < width; col++ ) {
            if((row >= mrow - hsize) && (row <= mrow + hsize) && (col <= mcol + hsize) && (col >= mcol - hsize)) {
                action_data.getInputImage1().setPixel(row, col, r,g,b);
            }
        }
    }
}


void configureGrid(ActionData& action_data) {
    int height, width, mcv;
    height = getInteger(action_data, "Grid Height?");
    width = getInteger(action_data, "Grid Width?");
    mcv = getInteger( action_data, "Grid Max Value?");
    action_data.getGrid().setGridSize(width, height);
    action_data.getGrid().setMaxNumber(mcv);
}

void setGrid(ActionData& action_data) {
    int row, col, val;
    row = getInteger(action_data, "Grid Row?");
    col = getInteger(action_data, "Grid Column?");
    val = getInteger( action_data, "Grid Value?");
    action_data.getGrid().setNumber(row, col, val);
}
void applyGrid(ActionData& action_data) {
    action_data.getGrid().setPPM(action_data.getOutputImage());
}
"""

controllers.cpp """

#include <iostream>
#include "image_menu.h"

int assignment1( std::istream& is, std::ostream& os) {
    ActionData action_data(is, os);
    return askQuestions3(action_data);
}

int assignment2( std::istream& is, std:: ostream& os ) {
    ActionData action_data(is, os);
    diagonalQuadPattern(action_data);
    copyImage(action_data);
    drawAsciiImage(action_data);
    return 0;
}

int assignment3( std::istream& is, std::ostream& os ) {
    ActionData action_data(is, os);
    stripedDiagonalPattern(action_data);
    copyImage(action_data);
    writeUserImage(action_data);
    return 0;
}

int hero( std::istream& is, std::ostream& os ) {
    ActionData action_data(is, os);
    return askHeroQuestions(action_data);
}

int simple_squares_ascii(std::istream& is, std::ostream& os) {
    ActionData action_data(is, os);
    simpleSquaresPattern(action_data);
    copyImage(action_data);
    drawAsciiImage(action_data);
    return 0;
}

void showMenu( MenuData& menu_data, ActionData& action_data ) {
    int num;
    std::string name, des, func;
    num = menu_data.getNames().size();
    for( int i=0; i<num; i++ ) {
        name = menu_data.getNames()[i];
        des = menu_data.getDescription(name);
        action_data.getOS() << name << ") " << des << std::endl;
    }
}

void takeAction(const std::string& choice, MenuData& menu_data, ActionData& action_data) {
    if(menu_data.getFunction(choice)) {
        menu_data.getFunction(choice)(action_data);
    } else if(choice == "menu") {
        showMenu( menu_data, action_data );
    } else {
        action_data.getOS() << "Unknown action '" << choice << "'." << std::endl;
    }
}

void configureMenu( MenuData& menu_data ) {
    ActionFunctionType drawAsci = &drawAsciiImage;
    ActionFunctionType write = &writeUserImage;
    ActionFunctionType cpyImage = &copyImage;
    ActionFunctionType readImage1 = &readUserImage1;
    ActionFunctionType comment = &commentLine;
    ActionFunctionType size = &setSize;
    ActionFunctionType setMCV = &setMaxColorValue;
    ActionFunctionType setChan = &setChannel;
    ActionFunctionType setPix = &setPixel;
    ActionFunctionType clear = &clearAll;
    ActionFunctionType qit = &quit;

    ActionFunctionType read2 = &readUserImage2;
    ActionFunctionType pluss = &plus;
    ActionFunctionType plusE = &plusEquals;
    ActionFunctionType minuss = &minus;
    ActionFunctionType minusE = &minusEquals;
    ActionFunctionType timess = &times;
    ActionFunctionType timesE = &timesEquals;
    ActionFunctionType dividee = &divide;
    ActionFunctionType divideE = &divideEquals;

    ActionFunctionType redg = &grayFromRed;
    ActionFunctionType greeng = &grayFromGreen;
    ActionFunctionType blueg = &grayFromBlue;
    ActionFunctionType ling = &grayFromLinearColorimetric;
    ActionFunctionType circ = &drawCircle;
    ActionFunctionType boxe = &drawBox;

    ActionFunctionType square = &drawSquare;
    ActionFunctionType orange = &orangeFilter;
    ActionFunctionType timesEp = &timesEqualsPPM;

    ActionFunctionType cG = &configureGrid;
    ActionFunctionType sG = &setGrid;
    ActionFunctionType aG = &applyGrid;

    menu_data.addAction("draw-ascii", drawAsci, "Write output image to terminal as ASCII art.");
    menu_data.addAction("write", write, "Write output image to file.");
    menu_data.addAction("copy", cpyImage, "Copy input image 1 to output image.");
    menu_data.addAction("read1", readImage1, "Read file into input image 1.");
    menu_data.addAction("#", comment, "Comment to end of line.");
    menu_data.addAction("size", size, "Set the size of input image 1.");
    menu_data.addAction("max-color-value", setMCV, "Set the max color value of input image 1.");
    menu_data.addAction("channel", setChan, "Set a channel value in input image 1.");
    menu_data.addAction("pixel", setPix, "Set a pixel's 3 values in input image 1.");
    menu_data.addAction("clear", clear, "Set all pixels to 0,0,0 in input image 1.");
    menu_data.addAction("quit", qit, "Quit.");

    menu_data.addAction("read2", read2, "Read file into input image 2.");
    menu_data.addAction("+", pluss, "Set output image from sum of input image 1 and input image 2.");
    menu_data.addAction("+=", plusE, "Set input image 1 by adding in input image 2.");
    menu_data.addAction("-", minuss, "Set output image from difference of input image 1 and input image 2.");
    menu_data.addAction("-=", minusE, "Set input image 1 by subtracting input image 2.");
    menu_data.addAction("*", timess, "Set output image from input image 1 multiplied by a number.");
    menu_data.addAction("*=", timesE, "Set input image 1 by multiplying by a number.");
    menu_data.addAction("/", dividee, "Set output image from input image 1 divided by a number.");
    menu_data.addAction("/=", divideE, "Set input image 1 by dividing by a number.");

    menu_data.addAction("red-gray", redg, "Set output image by grayscale from red on input image 1.");
    menu_data.addAction("green-gray", greeng, "Set output image by grayscale from green on input image 1.");
    menu_data.addAction("blue-gray", blueg, "Set output image by grayscale from blue on input image 1.");
    menu_data.addAction("linear-gray", ling, "Set output image by linear colorimetric grayscale on input image 1.");
    menu_data.addAction("circle", circ, "Draw a circle shape in input image 1.");
    menu_data.addAction("box", boxe, "Draw a box shape in input image 1.");

    menu_data.addAction("square", square, "Draw a square shape in input image 1.");
    menu_data.addAction("orange", orange, "Set output image from orange filter on input image 1.");
    menu_data.addAction("*=-ppm", timesEp, "Set input image 1 by multiplying by input image 2.");

    menu_data.addAction("grid", cG, "Configure the grid.");
    menu_data.addAction("grid-set", sG, "Set a single value in the grid.");
    menu_data.addAction("grid-apply", aG, "Use the grid values to set colors in the output image.");
}

int imageMenu( std::istream& is, std::ostream& os ) {
    ActionData action_data(is, os);
    action_data.setGrid( new NumberGrid );
    MenuData menu_data;
    configureMenu( menu_data );
    std::string choice;
    while( (action_data.getDone() != true) && (action_data.getIS().good())) {
        choice = getChoice( action_data );
        takeAction(choice, menu_data, action_data);
    }
    return 0;
}
"""


